{"posts":[{"title":"What Are You Talking About-数据结构-字典树（Trie）","content":"What Are You Talking About 来自 HDU OJ, 1075 登陆账号提交代码 Time Limit: 10000/5000 MS (Java/Others) Memory Limit: 102400/204800 K (Java/Others) Problem Description Ignatius1 is so lucky that he met a Martian yesterday. But he didn't know the language the Martians use. The Martian gives him a history book of Mars and a dictionary when it leaves. Now Ignatius want to translate the history book into English. Can you help him? 问题描述： 伊格那修是如此幸运啊，他昨天遇见了一个火星人！但是他并不理解火星人使用的语言。这位火星人离开时留下一本火星人的历史书和一本字典。现在伊格那修想要把这那本历史书翻译成英文。你能帮帮他吗？2 Input The problem has only one test case, the test case consists of two parts, the dictionary part and the book part. The dictionary part starts with a single line contains a string &quot;START&quot;, this string should be ignored, then some lines follow, each line contains two strings, the first one is a word in English, the second one is the corresponding word in Martian's language. A line with a single string &quot;END&quot; indicates the end of the directory part, and this string should be ignored. The book part starts with a single line contains a string &quot;START&quot;, this string should be ignored, then an article written in Martian's language. You should translate the article into English with the dictionary. If you find the word in the dictionary you should translate it and write the new word into your translation, if you can't find the word in the dictionary you do not have to translate it, and just copy the old word to your translation. Space(' '), tab('\\t'), enter('\\n') and all the punctuation should not be translated. A line with a single string &quot;END&quot; indicates the end of the book part, and that's also the end of the input. All the words are in the lowercase, and each word will contain at most 10 characters, and each line will contain at most 3000 characters. 输入： 这个问题只有一个测试用例，这个测试用例由两部分组成——字典部分和历史书的部分。字典部分以包含一个字符串 &quot;START&quot; 的单行开始，这个字符串应该要被忽略，然后紧跟着几行，每行包括两个字符串，第一个字符串是一个英语单词，第二个字符串是一个与其相对应的火星语单词。而单个字符串 &quot;END&quot; 表示字典部分结束，并且这个字符串应该要被忽略。书本部分以一个包括字符串 ”START“ 的单行开始，这个字符串同样需要被忽略，然后是一篇以火星语写成的文章。你要用字典部分把这篇文章翻译成英文。如果你在字典中找到了对应的单词你应该要把它翻译并写入你的译文中，如果你不能找到就不必翻译，只需把原词抄录到你的译文中。空格(' '), 制表符('\\t'), 换行符('\\n') 和所有的标点符号都不要翻译。一个字符串 ”END“ 表示书本部分的结束，同时这也是输入部分的结束。所有的单词都是小写，并且每个单词最多包括 10 个字符， 并且每行最多包含 3000 个字符。 Output In this problem, you have to output the translation of the history book. 输出： 在这个问题中，你需要输出这本历史书的译文。 Sample Input Sample Output Hint Huge input, scanf is recommended. 提示： 庞大输入，建议使用输入函数 scanf() 。 Author Ignatius. L 解法一 ​ 考虑到一个英文单词对应一个火星文单词，使用 C++ STL 中的 map 可以较为简单的完成此题。 解法二 ​ 这里可以用一个字典树（Tried树）来保存英文单词，字典树中用边代表单词中的字母。 ​ 在计算机科学中，trie，又称前缀树或字典树，是一种有序树，用于保存关联数组，其中的键通常是字符串。与二叉查找树不同，键不是直接保存在节点中，而是由节点在树中的位置决定。一个节点的所有子孙都有相同的前缀，也就是这个节点对应的字符串，而根节点对应空字符串。一般情况下，不是所有的节点都有对应的值，只有叶子节点和部分内部节点所对应的键才有相关的值。 关于我的代码有两点需要提一下： 这里为了水题，在这个 Trie 类中缺少析构函数，主要是因为我偷懒，如果需要写的话要用递归方法 delete 掉 new 出来的空间。 Trie 类主要用到增、查，一般不用删除，这个类没有这个方法，我又偷懒了。 算法分析 ​ C++ STL中的 map 和 字典树在效率方面区别主要体现在查找。 ​ 在时间方面对于 map 由于查找的时候用的是红黑树实现，在 n 个条目的字典中效率为 O(log n) ，若字符串长度为 m 则还要算上比较的时间，总的复杂度为 O(m×log n)。而对对于 Trie，查找的时间只与字符串长度有关因此只需 O(m)，就可以完成。3 但是 Trie 事实上是一中空间换时间的做法，为了保存一个字符往往需要含 26 个指针的节点来保存，但是如果有相同前缀的字符串较多，存储密度就会高的多。 在这题中的提交结果也展示出了符合预期的结果。 数据结构\\效率 时间 空间 C++ STL map 1996 MS 73608 K Trie 1575 MS 128736 K -[1] 这道题的作者为 Ignatius. L 个人猜测昵称灵感来自 San Ignacio de Loyola （1491年－1556年7月31日，西班牙人，耶稣会创始人，罗马公教圣人之一。他在罗马公教会内进行改革，以对抗由马丁·路德等人所领导的宗教改革。 -[2] &quot;那你能帮帮我吗？&quot; -[3] 需要注意其他 C++ 内置数据类型和字符串在查找效率方面的区别。 std::map and std::set are implemented by compiler vendors using highly balanced binary search trees (e.g. red-black tree, AVL tree). As correctly pointed out by David, find would take O(log n) time, where n is the number of elements in the container. But that's with primitive data types like int, long, char, double etc., not with strings. If std:string, lets say of size 'm', is used as key, traversing the height of the balanced binary search tree will require log n comparisons of the given key with an entry of the tree. When std::string is the key of the std::map or std::set, find and insert operations will cost O(m log n), where m is the length of given string that needs to be found. 来自 stack-overflow 论坛 Time complexity of find() in std::map? , answered Jul 10 '13 at 2:24 by Arif Ali Saiyed 这里还了解到下次可以试一试 std::unordered_map （ 查找的平均时间复杂度为O(1) ）来做这一道题。 ","link":"https://taivasjumala.github.io/post/what-are-you-talking-about/"}]}